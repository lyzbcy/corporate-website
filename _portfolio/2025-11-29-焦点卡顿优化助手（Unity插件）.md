---
title: 焦点卡顿优化助手（Unity插件）
subtitle: 智能托管 Unity 资源刷新机制，彻底解决切换窗口卡顿痛点
image: assets/img/作品集/焦点卡顿优化助手/焦点控制助手宣传图_01.jpg
alt: 焦点优化助手插件界面
category: personal
featured: true

caption:
  title: 焦点卡顿优化助手（Unity插件）
  subtitle: Unity Editor Performance Tool
  thumbnail: assets/img/作品集/焦点卡顿优化助手/焦点控制助手宣传图_01.jpg
---

<div class="q-bounce-content" markdown="1">

## 📊 项目信息
- **完成时间**: 2025年11月
- **项目类型**: Unity 编辑器性能优化工具
- **核心技术**: C#, AssetDatabase API, FileSystemWatcher, Editor Internal Utility

## 1. Focus Optimizer (焦点卡顿优化助手)

### 📋 功能简介
<img src="assets/img/作品集/焦点卡顿优化助手/焦点控制助手宣传图_02.jpg" class="img-fluid d-block mx-auto" alt="焦点控制助手宣传图_02">
针对 Unity 编辑器在切换窗口（失去/获取焦点）时频繁触发 `AssetDatabase.Refresh` 导致卡顿的问题，**Focus Optimizer** 接管了编辑器的资源刷新机制。它在编辑器后台运行时暂停刷新，在切回前台时根据文件变动情况智能执行刷新策略，显著提升了开发时的流畅度。

## 2. 技术栈 (Technology Stack)

### 核心技术
*   **开发语言**: C# (Unity Editor)
*   **运行环境**: Unity Editor (Editor Scripting)
*   **API 依赖**:
    *   `UnityEditor.AssetDatabase`: 控制资源数据库的刷新与锁定。
    *   `UnityEditor.EditorApplication`: 监听编辑器的生命周期与 Update 帧。
    *   `System.IO.FileSystemWatcher`: 独立于 Unity 的文件系统监控。

### 关键系统 API
*   **`InternalEditorUtility.isApplicationActive`**: 用于在 `EditorApplication.update` 中精确检测 Unity 窗口的焦点获取与丢失状态。
*   **`FileSystemWatcher`**: 核心组件之一。当 Unity 失去焦点并暂停自动刷新时，该组件接管对 `Assets`、`Packages` 和 `ProjectSettings` 目录的监控，记录外部文件变动。

## 3. 架构与实现细节
<img src="assets/img/作品集/焦点卡顿优化助手/焦点控制助手宣传图_04.jpg" class="img-fluid d-block mx-auto" alt="焦点控制助手宣传图_04">

本项目采用**拦截-监控-决策**的架构模式。

### 3.1 焦点状态管理 (`FocusOptimizerController.cs`)
这是插件的中枢控制器，负责协调各个子系统。
*   **生命周期挂钩**: 使用 `[InitializeOnLoad]` 确保编辑器启动时立即生效。
*   **焦点事件处理**:
    *   **失去焦点 (Lost Focus)**: 调用 `AssetDatabase.DisallowAutoRefresh()` 彻底暂停 Unity 的自动刷新机制，防止无意义的后台 CPU 占用和卡顿。同时启动 `FocusChangeTracker`。
    *   **获取焦点 (Gain Focus)**: 获取后台期间积累的文件变动数量，根据用户配置的策略（立即刷新、限流刷新、手动刷新）决定下一步操作。

### 3.2 独立文件监控体系 (`FocusChangeTracker.cs`)
为了在 Unity 暂停刷新期间（`kAutoRefresh` 被禁用）仍然掌握项目变动，插件实现了一套独立的文件监控层。
*   **多目录监听**: 并行监控关键目录（Assets, Packages 等），使用 `NotifyFilters` 过滤文件大小、写入时间等变动。
*   **线程安全与缓冲区**: 由于 `FileSystemWatcher` 回调运行在系统线程池，代码使用了 `lock` 机制和缓冲区策略（`ChangedPaths` HashSet）来安全地记录变动路径，并去重。
*   **性能保护**: 设置了最大记录上限（如 5000 条），防止在发生大规模文件操作（如 Git 切换分支）时内存溢出。

### 3.3 增量导入与限流 (`FocusBackgroundImporter.cs`)
*   **限流刷新 (Throttling)**: 不仅仅是简单的延时调用，而是结合了时间戳判断，避免在用户高频切换窗口时触发多次刷新。
*   **实验性后台导入**: 尝试在编辑器空闲时段，分批次（`MaxImportsPerCycle`）主动调用 `AssetDatabase.ImportAsset`，以平摊主线程的卡顿峰值。

### 3.4 播放模式优化 (`EnterPlayModeOptionHelper.cs`)
*   **Preset 注入**: 利用 `EditorSettings.enterPlayModeOptions` API，动态注入“禁用 Domain Reload”或“禁用 Scene Reload”的配置，加速进入 Play Mode 的过程，并在必要时自动还原用户原有设置。

## 4. 💡 创新点

### “监控-拦截-决策”架构
并非简单地屏蔽刷新，而是通过独立监控层掌握变动详情。如果变动量巨大（如 Git 切换分支导致上千个文件变化），它会智能拦截并询问用户“这可能是一次昂贵的刷新”，防止编辑器直接卡死。

### 无感介入
对用户完全透明，安装即生效。它巧妙地平衡了“数据实时性”与“编辑器流畅度”，显著提升了开发过程中频繁查阅文档、操作外部工具时的体验。

### 资源锁安全管理
使用 `AssetDatabase.DisallowAutoRefresh()` 和 `AllowAutoRefresh()` 配对调用，并维护内部状态标志位，能够从异常状态中自动恢复，防止编辑器永久处于不刷新状态。

## 5. 性能指标
*   **监控开销**: `FileSystemWatcher` 运行在独立线程，对主线程几乎无影响。
*   **Update 开销**: 极低。每帧仅是一个布尔值检查 (`isApplicationActive`)，耗时操作均被分摊或按需触发。

## 6. 🤕 技术难点与解决方案

### 6.1 技术选型的演进
**挑战**: 在早期调研阶段，我发现市面上存在多种优化方案，如单纯禁用刷新、手动刷新或通过 Shell 脚本劫持。
**解决**:
*   借助 AI 辅助调研，对比了各种方案的优劣。
*   最终确定了**“接管而非屏蔽”**的技术路线：既要阻止无用的自动刷新，又要保证重要数据的实时性，因此引入了系统级 `FileSystemWatcher` 作为补位。

### 6.2 现有局限与优化方向
**反思**: 虽然目前的“延迟刷新”策略解决了卡顿痛点，但本质上仍是对 Unity 现有机制的妥协，而非底层重构。
**展望**:
*   未来计划探索更深层的**增量导入管线**，尝试在后台线程预处理资源数据。
*   虽然当前方案“不够完美”，但它是在现有 API 限制下，平衡性能与稳定性的**最优解**。

</div>